import json
import logging
import aiohttp
from aiohttp import ClientError
from homeassistant.core import HomeAssistant

_LOGGER = logging.getLogger(__name__)

# Constants
BASE_URL = "https://auth.smyoo.com"
APP_ID = 1314
AREA_ID = 1

class SmyooAuthError(Exception):
    """Raised when authentication fails."""
    pass

class SmyooApiClient:
    """Handles communication with the Smyoo API."""

    def __init__(self, hass: HomeAssistant, phone: str, password: str):
        self.hass = hass
        # API requires +86-13... format, adjusting input phone
        self.phone = phone if phone.startswith('+86-') else f'+86-{phone}'
        self.password = password
        
        # 使用单个 ClientSession 管理会话和 Cookie
        self.session = aiohttp.ClientSession() 
        self.user_agent = 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/132.0.0.0 Safari/537.36 NetType/WIFI MicroMessenger/7.0.20.1781(0x6700143B) WindowsWechat(0x63090a13) UnifiedPCWindowsWechat(0xf254162e) XWEB/18151 Flue'
        
        self.bpe_session_id = None
        self.ticket = None
        self.devices = []
        
    async def _get_bpe_session_id_from_cookie(self):
        """Helper to extract BpeSessionId from the current session cookies."""
        bpe_id = None
        for cookie in self.session.cookie_jar:
            if cookie.key == 'BpeSessionId':
                bpe_id = cookie.value
                break
        
        self.bpe_session_id = bpe_id
        return bpe_id

    async def _request(self, method, url, **kwargs):
        """Wrapper for aiohttp request."""
        headers = {
            'User-Agent': self.user_agent,
            'Accept-Language': 'zh-CN,zh;q=0.9',
            'X-Requested-With': 'XMLHttpRequest',
            'Origin': BASE_URL,
            'Sec-Fetch-Site': 'same-origin',
            'Sec-Fetch-Mode': 'cors',
            'Sec-Fetch-Dest': 'empty',
        }
        
        if 'headers' in kwargs:
            headers.update(kwargs.pop('headers'))

        try:
            async with self.session.request(method, url, headers=headers, **kwargs) as response:
                response.raise_for_status()
                # 尝试返回 JSON
                try:
                    return await response.json()
                except aiohttp.ContentTypeError:
                    _LOGGER.warning("Received non-JSON response from %s. Status: %s", url, response.status)
                    return None
        except ClientError as err:
            _LOGGER.error("API request failed to %s: %s", url, err)
            raise

    async def async_login(self):
        """Step 1 & 2: Perform the two-step login process."""
        
        # --- Capture 1: synweblogin (GET) ---
        _LOGGER.debug("Starting login step 1: synweblogin")
        login_url = f"{BASE_URL}/v1/account/synweblogin"
        params = {
            'appid': APP_ID,
            'areaid': AREA_ID,
            'phone': self.phone,
            'password': self.password,
            'locale': 'zh_CN',
            'autologin': 'true'
        }
        
        headers_step1 = {
            'Referer': f'{BASE_URL}/app_login.html?callbackurl={BASE_URL}/devices/devicesIndex.html',
            'Accept': 'application/json, text/javascript, */*; q=0.01'
        }
        
        data1 = await self._request("GET", login_url, params=params, headers=headers_step1)
        
        if not data1 or data1.get('code') != 0:
            raise SmyooAuthError(f"Login failed: {data1.get('msg', 'Unknown error')}")
            
        self.ticket = data1['data']['ticket']
        
        # --- Capture 2: synloginMobile (POST) ---
        _LOGGER.debug("Starting login step 2: synloginMobile")
        synlogin_url = f"{BASE_URL}/api/gfriend/synloginMobile"
        
        payload = {
            "BpeSessionId": "",
            "appId": APP_ID,
            "endpointOS": "",
            "clientVersion": "",
            "ticket": self.ticket,
            "deviceId": "",
            "context": ""
        }
        
        headers_step2 = {
            'Content-Type': 'application/json',
            'Referer': f'{BASE_URL}/app_login.html?callbackurl={BASE_URL}/devices/devicesIndex.html',
        }

        data2 = await self._request("POST", synlogin_url, json=payload, headers=headers_step2)
        
        if not data2 or data2.get('resultCode') != 0:
            raise SmyooAuthError(f"Session setup failed: {data2.get('resultMsg', 'Unknown error')}")

        # Extract BpeSessionId cookie generated by step 2
        await self._get_bpe_session_id_from_cookie()
        if not self.bpe_session_id:
             _LOGGER.warning("BpeSessionId cookie not found after login step 2.")

        _LOGGER.info("Successfully logged in and established session.")
        return True

    async def async_query_devices(self):
        """
        Step 3: Query device list and transform data into the dictionary 
        format expected by Home Assistant: {"switches": {id: device_info}}.
        """
        
        if not self.ticket:
            await self.async_login()
        
        await self._get_bpe_session_id_from_cookie()
        if not self.bpe_session_id:
            _LOGGER.error("Cannot query devices: BpeSessionId is missing.")
            return {"switches": {}} 

        _LOGGER.debug("Querying devices.")
        query_url = f"{BASE_URL}/api/gfriend/querydevices"
        
        payload = {
            "appId": str(APP_ID),
            "endpointOS": "",
            "clientVersion": "",
            "deviceId": "",
            "BpeSessionId": self.bpe_session_id,
            "locale": ""
        }
        
        headers_query = {
            'Content-Type': 'application/json',
            'Referer': f'{BASE_URL}/devices/devicesIndex.html',
        }

        try:
            data = await self._request("POST", query_url, json=payload, headers=headers_query)
        except Exception as err:
            _LOGGER.error("API request for devices failed: %s", err)
            return {"switches": {}}


        if not data or data.get('resultCode') != 0:
            _LOGGER.error("Failed to query devices: %s", data.get('resultMsg'))
            return {"switches": {}}

        try:
            # mcuinfos is a JSON string *inside* the main JSON response
            mcuinfos_str = data['data']['mcuinfos']
            devices_raw = json.loads(mcuinfos_str)
        except (KeyError, json.JSONDecodeError, TypeError):
            _LOGGER.error("Failed to parse device data structure from API response: %s", data)
            return {"switches": {}}
        
        devices_list = []
        for dev in devices_raw:
            try:
                # datapoint is also a JSON string
                datapoint = json.loads(dev['datapoint'])
            except json.JSONDecodeError:
                _LOGGER.warning("Could not parse datapoint for device %s", dev.get('mcuid'))
                datapoint = {}

            device_info = {
                'id': dev['mcuid'],
                'name': dev['mcuname'].strip(),
                'is_online': dev['isonline'] == 1,
                # 转换状态 (0/1) 为 HA 期望的 ('on'/'off') 字符串
                'state': 'on' if datapoint.get('status', 0) == 1 else 'off', 
                'raw_info': dev
            }
            devices_list.append(device_info)
        
        self.devices = devices_list
        
        # 1. 转换列表为 Home Assistant 协调器期望的字典结构
        switches_dict = {}
        for device in devices_list:
            device_id = device['id']
            # 使用 ID 作为键，并将完整的设备信息字典作为值
            switches_dict[device_id] = device
        
        # 2. 返回包含 'switches' 键的大字典
        ha_data = {
            "switches": switches_dict
        }
        
        _LOGGER.debug("API Query finished. Found %d switches.", len(switches_dict))
        
        return ha_data

    async def async_set_device_state(self, mcuid: str, status: bool):
        """Step 4: Set device state (ON=1, OFF=0)."""
        
        await self._get_bpe_session_id_from_cookie()
        if not self.bpe_session_id:
            _LOGGER.error("Cannot set state: BpeSessionId is missing.")
            return False

        set_url = f"{BASE_URL}/api/gfriend/setdevicedata"
        
        api_status = 1 if status else 0
        # datapoint 必须是 JSON 字符串
        datapoint_payload = json.dumps({"status": api_status})
        
        payload = {
            "appId": str(APP_ID),
            "BpeSessionId": self.bpe_session_id,
            "endpointOS": "",
            "clientVersion": "",
            "deviceId": "",
            "locale": "",
            "mcuid": mcuid,
            "datatype": 1,
            "datapoint": datapoint_payload 
        }
        
        headers_set = {
            'Content-Type': 'application/json',
            'Referer': f'{BASE_URL}/devices/devicesIndex.html',
        }

        try:
            data = await self._request("POST", set_url, json=payload, headers=headers_set)
        except Exception as err:
             _LOGGER.error("API request to set device state failed for %s: %s", mcuid, err)
             return False

        if not data or data.get('resultCode') != 0:
            _LOGGER.error("Failed to set device state for %s: %s", mcuid, data.get('resultMsg', 'Unknown response'))
            return False
        
        _LOGGER.debug("Device %s set to status %s successfully.", mcuid, api_status)
        return True
